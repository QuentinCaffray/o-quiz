# SC03E01 - Authentification

Théorie :
- Stratégies d'authentification
- Approches `Stateless` et `Stateful`
- Diagrammes de séquences

Pratique :
- `/auth/register` (**sign up**)
  - validation des données
  - hachage du mot de passe
  - tests
- `/auth/login` (**sign in**)
  - validation des identifiants
  - génération d'un JWT signé
  - analyse du JWT
  - stratégie de transmission et stockage (sécurité)
  - (bonus) refresh token
  - tests

Challenge :
- `/auth/refresh`
  - récupération et validation du refresh token
  - émission d'un nouveau couple tokens
  - tests
- `/auth/me`
  - vérification et décodage du token d'accès
  - récupération des données utilisateur
  - tests
- `/auth/logout` (**sign out**)
  - suppression (invalidation) des cookies
  - suppression/invalidation des refresh tokens


## Register (Sign up) - Création d'un compte

- POST `/auth/login`
  - Body : 
    - firstname
    - lastname
    - email
    - password

On commence par quoi ? 
- Modèle ✅
  - `model User` (schema prisma)
- Router : 
  - `auth.router.ts`
- Controlleur : 
  - `auth.controller.ts`
  - `auth.controller.spec.test.ts`


## Méthodes prisma

```js
findUnique(...):             Model | null       // Renvoie l'enregistrement unique ou NULL s'il n'existe pas
findUniqueOrThrow(... )      Model              // Renvoie l'enregistrement unique ou lève une PrismaError s'il n'existe pas

findFirst(...)               Model | null       // Renvoie l'enregistrement (le premier trouvé qui match la query) ou NULL s'il n'y en a aucun
findFirstOrThrow(...)        Model              // Renvoie l'enregistrement (le premier trouvé qui match la query) ou PrismaError levé
```


## Hachage de mot de passe

Vocabulaire : 
- **hachage** : **opération à sens unique**
  - ex : un mot de passe haché ne peut pas être dé-haché
    - (en revanche il pourra être "comparé" sous sa forme haché)
- **chiffrement** : **opération à double sens**
  - ex : un message chiffré (envoyé en HTTS) peut être déchiffré
    - (en général, à l'aide d'une clé de déchiffrement)
    - ex : code césar

Vocabulaire à [bannir](https://chiffrer.info/) : 
- ❌ crypter
- ❌ encrypter
- ❌ chiffrage


En particulier : 
- on hache les mot de passe en BDD
  - car sinon, un attaquant qui a potentiellement accès à la BDD pourrait déchiffrer les mots de passe !

Quelle technologique utiliser :
- [recommandations](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html) de **OWASP : Open Worldwide Application Security Project**
  - organisme but non lucratif pour la sécurité du web

```bash
# https://www.npmjs.com/package/argon2
npm install --prefix api argon2
```

```ts
import argon2 from "argon2";

// Haché un mot de passe
const hashedPassword = await argon2.hash("RAW_PASSWORD");
```

Un même mot de passe va être haché différemment à grâce à un méchanisme : le **SEL**.

```
// Toto42!!
$argon2id$v=19$m=65536,t=3,p=4$9OqxLDEXAnvlNNQ7Zxmfrg$Kv1MTW0I5Bd1cGVmcwaFd8EOkfm1xSJjbZiTwXh1tBE

// Toto42!!
$argon2id$v=19$m=65536,t=3,p=4$IQD1IZyxPyke5XQyumKkjw$rxLi/YTJrv8BhLeLxn30fbOomkLzWYdF9W1q+VsbiDg

$argon2id --> nom de l'algo
         $v=19 --> version de l'algo
              $m=65536 --> mémoire utilisé par l'algo (RAM)
                       t=3 --> nombre d'itération du hashage
                           p=4  --> parallélisme
                              $IQD1IZyxPyke5XQyumKkjw --> sel, généré par argon2
                                                    $rxLi/YTJrv8BhLeLxn30fbOomkLzWYdF9W1q+VsbiDg --> hash
```

Pourquoi ? 
- Un **sel est une chaine de caractère aléatoire ajouté au mot de passe avant de le hasher.**
- car si même mot de passe se hash de la même manière, alors tous les utilisateurs avec le mot de passe "password" auront le même hash en BDD
- donc un attaquant verrait que le hash apparait souvent => en déduit que c'est un mot de passe simple !
- "Un mot de passe n'est pas forcément unique à l'origine mais le mdp haché lui l'est" (Amélia)

## Gestion des mots de passe

Gestionnaire de mot de passe : 
- `Bitwarden` (Open Source)
- `1Password`
- `Dashlane`
- `Nordpass`

On mémorise un **mot de passe FORT/MAITRE** (suffisamment complexe) et le gestionnaire se charge de sauvegarder les mots de passe de vos autres services.
- évite d'avoir le même mot de passe sur chaque site


## Générer un JWT : Json Web Token

On peut utiliser la librairie `json-web-token`

```bash
npm install json-web-token --prefix api
```

## Refresh token

- Alice se connecte via le formulaire de connexion
  - le serveur lui génère un JWT, qu'elle stock dans les "Cookies"
  - le serveur lui génère un Refresh Token, qu'elle stock dans les "Cookies"

- Alice navigue sur la plateforme **pendant 1h**
  - à chaque requête, elle transmet le cookie JWT (Access Token) pour s'authentifier auprès de l'API

- Au bout d'1h, Alice essaie d'accéder à la page Dashboard, qui envoie une requête vers `/api/dashboard` avec le JWT (comme d'hab)
  - il n'est plus valide => `401` (Expired token)
  - automatiquement, le code front sur-enchéri (dans le dos d'Alice) et renvoie une nouvelle requête vers `/api/auth/refresh` en transmettant le **refresh token**
    - SI LE REFRESH TOKEN EST VALIDE (< 7jours) ==> 
      - elle reçoit un nouveau `ACCESS_TOKEN` + `REFRESH_TOKEN` (qu'elle stock dans les cookies)
      - elle refait ensuite la requête vers `/api/dashboard` automatiquement avec le nouveau JWT tout frais 
    - SI LE REFRESH TOKEN N'EST PLUS VALIDE (> 7jours) ==> 
      - elle reçoit une 401 (le token n'est plus valide)
      - le front la redirige vers la page de login pour recommencer du début (du `/api/login`)


### Mise en place

- Puisqu'on va stocker les Refresh Token en BDD, il faut aller : 
  - modifier le schéma prisma
  - lancer les migrations !
