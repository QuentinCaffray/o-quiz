# SC02E04 - Automatisation

## Menu du jour

**Correction (API & Tests)**
- Routes 
  - `/levels`
- Validation
  - `Zod`
- Gestion des erreurs
  - `Global error handler`
- Tests
  - 1 controller = 1 test

**Automatisation**
- Qualit√© logicielle
  - `Linter` (ESLint)
  - `Husky` (pr√©-commit hook)
- DevOps
  - `GitHub Action` (Pipeline CI)
  - Diagramme d'activit√© (UML)

## Linter

**Outils d'analyse statique de code** : analyser le code dans l'√©diteur, sans l'ex√©cuter.

Objectif : 
- v√©rifier des potentiels bugs
  - ex : on d√©finir une variable deux fois
- v√©rifier des potentiels incoh√©nces
  - ex : on d√©fini une variable que l'on utilise pas
- v√©rifier les mauvaises pratiques
  - ex : on oublie des `;` aux endroits o√π ils sont n√©cessaire
  - ex : on utilise `==` au lieu de `===`
- garder une coh√©rence/homog√©n√©it√© dans le d√©p√¥t et dans l'√©quipe
  - ex : on s'assure que tout le monde code avec la m√™me indentation

Linter dans l'eco-syst√®me JavaScript : 
- `ESLint`
- `Biome`
- `Oxlint`

Un **linter** peut v√©rifier des **r√®gles compl√©mentaires** √† ce que v√©rifie le compilateur TypeScript :
- ex : comparaison strict/souple
- ex : interdiction d'utiliser `let`
- ex : interdire certaines fonctions 
  - (`Number("42")` au lieu de `Number.parseInt("42")`)


Un **formatter**, contrairement √† un linter, s'occupe principalement du **style** de code (indentations, nom des fonctions...) : 
- `Prettier`

Certains linter ont des r√®gles de formatage. Par exemple, il y a des r√®gles de formatage sur ESLint (`indentation`)


En entreprise, on travail avec l'√©co-syst√®me qui nous est impos√© : 
- formatage automatique pour tout le monde => pas le choix
- tr√®s forte chance qu'il y ait un `linter`.

### ESLint

#### L'extension VSCode

`ESLint` (par `Microsoft`) √† installer une fois pour toute.

- L'objectif : d'avoir la coloration syntaxique du linter dans l'√©diteur quand on code.
- On pourrait s'en passer
- Ce n'est pas cette action qui installe ESLint dans le projet

#### Installer ESLint dans le projet

```bash
npm install --save-dev --prefix api eslint @eslint/js typescript-eslint
```

#### Configurer ESLint dans le projet

```bash
touch eslint.config.js 
# ou .mjs si on a pas le type:module dans le package.json
```

```js
// Celle de la doc
// @ts-check

import eslint from '@eslint/js';
import { defineConfig } from 'eslint/config';
import tseslint from 'typescript-eslint';

export default defineConfig(
  eslint.configs.recommended,
  tseslint.configs.recommended,
);
```

```js
// @ts-check

import eslint from '@eslint/js';
import { defineConfig } from 'eslint/config';
import tseslint from 'typescript-eslint';

export default defineConfig(
  eslint.configs.recommended,
  tseslint.configs.recommended,
  {
    rules: { // On d√©fini nos propres r√®gles = au choix, selon l'√©quipe avec qui on travail
      'semi': ['error', 'always'], // ; obligatoire en fin d'instruction
      'indent': ['error', 2], // (Convetion JS) L'intentation du code doit √™tre de 2 espaces
      '@typescript-eslint/no-explicit-any': 'off', // on autorise "any" partout pour se faciliter la vie en tant que d√©butant TypeScript
    },
  },
  {
    ignores: ["dist", "node_modules", "prisma/generated", "test/report"], // Dossiers qui ne seront pas analyser par ESLint
  }
);
```

#### V√©rifier le bon fonctionnement du linter

```bash
# Depuis le terminal
cd api

# Tester
npx eslint .

# Auto-fixer les probl√®mes "auto-fixables" 
# ex : indentation, et points virgules
npx eslint . --fix 
```

#### Ajout de scripts

```json
"lint": "eslint ."
"lint:fix": "eslint . --fix"
```

#### Automatisation

- Il est possible de faire en sorte que VSCode lance automatiquement le linter (et/ou le formateur) **au moment o√π l'on sauvegarde le code**
  - approche "opinonated" (√† la discretion de chacun)
- A d√©faut, nous allons lancement automatiquement le linter (et/ou le formateur) **au moment o√π l'on commit**
  - √† l'aide d'un outil : `Husky`


## Husky

Deux approche : 
- ‚ùå l'installer dans le dossier `api` 
  - (mais on aura 2 commandes `bash` √† faire en plus)
- ‚úÖ l'installer √† la racine du projet 
  - (mais on aura 1 `package.json` en plus, global au projet)

```bash
# A la racine du projet
npm install --save-dev husky

# On pense √† modifier le .gitignore global pour retirer les node_modules

# On initialise Husky
npx husky init
# G√©n√®re un fichier .husky/pre-commit

# Modifier le fichier .husky/pre-commit
npm run lint --prefix api # pour linter au moment du commit !
```


La question : 
- si Husky ne lance pas les tests automatis√©s, qui s'en charge ? 
  - le d√©veloppeur, √† son bon vouloir
    - oublie potentiel
  - **la PULL REQUEST elle-m√™me qui lance les tests** 


## Int√©gration Continu (CI) et D√©ploiement Continu (CD)

- **CI** = Continuous Integration = **faciliter l'int√©gration de nouveau code √† la branche principale, tout en s'assurant de la bonne qualit√©**
  - ex : pre-commit hook Husky qui lance le linter 
  - ex : lancer automatiquement les tests sur GitHub avant de merger une branche
  - ex : v√©rifier que la cr√©ation des dossiers `dist` fonctionnent bien (build)
  - => plut√¥t en phase de dev

- **CD** = Continuous Deployment = **faciliter le d√©ploiement du nouveau code, sans impacter l'exp√©rience utilisateur**
  - ex : lors d'un merge sur master, alors notre serveur VPS de prod pull automatique le code et relance les conteneurs (git hook)
  - ex : lors d'un merge sur master, on build les images docker et on les push automatiquement sur le DockerHub
  - => plut√¥t en phrase de prod


Outils CI/CD = 
- Jenkins
- GitLab CI
- GitHub Action


On veut =
- √† chaque ouverture de Pull Request vers la branche `main`/`master`
- alors on lance automatiquement les tests unitaires et d'int√©gration du backend
- SI OK = on nous laisse merger la PR
- SI KO = le merge est bloqu√©


Diff√©rence avec Husky :
- Husky tourne en **local** (pr√©-commit)
- GitHub Action tourne **sur GitHub** (pr√©-merge)

=> Finalement, les deux approches sont compl√©mentaires : 
- `CODE` => `PRE-COMMIT HUSKY` (ü§ñ) => `PUSH` => `PR` => `GHA Tests` (ü§ñ) => `MERGE`

### Mise en place de GitHub Action 

Cr√©er un fichier `.github/workflows/pipeline-ci-api.yml`


### Pull Request

**PR** = **Pull Request** = demande d'int√©gration des commits d'une branche vers une autre branche.

Int√©r√™ts : 
- √©viter de tout coder sur la branche principale (`main`/`master`)
  - plus facile √† revenir en arri√®re si on fait des b√©tises
  - si on travaille √† plusieurs, on code pas tous sur la m√™me branche (conflits √† g√©rer)
- se relire 
  - on prend un temps pour RELIRE les `files changed` et ajuster
  - historique des √©volutions du d√©p√¥t
- d√©clencher les actions automatiques
  - nos pipelines, qui lancent nos tests d'avant d'int√©grer dans la branche principale


## Controlleur `POST /levels`

```js

export async function createLevel(req: Request, res: Response) {
  const levelName = req.body.name;

  const createdLevel = await prisma.level.create({ data: { name: levelName } });

  res.json(createdLevel);
}
```


Probl√®mes du controleurs : 

- **PROBLEME DE DOUBLON** :
Si le niveau existe d√©j√† dans la BDD, j'ai une erreur 500
	- il faudrait plut√¥t : 409 (Conflict)
	- l'√©tat du serveur ne permet pas de cr√©er cette entit√© car elle existe d√©j√†


- **VERIFICATION DES DONNEES** : 
Il faut s'assurer que l'utilisateur fourni bien un nom complet (et pas un bool√©en par exemple ou un name vide)
	- actuellement : 500
	- on veut : 422 (ou 400) Unprocessable Entity


- **AUTORISATION (SC03E02)** : 
V√©rifier que l'utilisateur est un auteur avant de cr√©er le level



- **SECURITE : (SC03E04)**
V√©rifier que le contenu du body ne contient pas d'injection (XSS ou SQL)


- **PLANTAGE BDD**
	- on veut renvoyer une 500 sans donner trop d'information
	- mais tout en pr√©servant l'√©tat du serveur API
	- ==> try/catch


- **STATUS CODE RETOUR**
	- on a : 200
	- on veut : 201



## Axios

Une librairie qui sert √† faire des requ√™tes HTTP (comme `fetch`) mais avec plus de fonctionnalit√©s pratiques.

Ici, on l'utilise surtout pour la simplicit√© de sa syntaxe

### Int√©r√™t n¬∞1 : syntaxe simplifi√©

```js
// GET (fetch)
const httpResponse = await fetch(URL);
const data = await httResponse.json(); // Notre body est dans "data"

// GET (axios)
const { data } = await axios.get(URL); // Notre body est dans "data"
```

```js
// POST (fetch)
const httpResponse = await fetch(URL, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(BODY)
});
const data = await httpResponse.json();

// POST (axios)
const { data } = await axios.post(URL, BODY);
```


### Int√©r√™t n¬∞2 : 

Possibilit√© de cr√©er des instances axios pr√©-configur√©es

```js
// Fetch
await fetch("http://localhost:7357/api/users");
await fetch("http://localhost:7357/api/levels");
await fetch("http://localhost:7357/api/tags");


// Axios
const instanceAxios = axios.create({
  baseUrl: "http://localhost:7357/api"
});

await instanceAxios.get("/users");
await instanceAxios.get("/levels");
await instanceAxios.get("/tags");
```


Note : `axios` l√®ve une exception quand la r√©ponse API est `4XX` ou `5XX` (contrairement √† `fetch` qui consid√®re que ce n'est pas une erreur).
- Pour √©viter √ßa, on peut rajouter `validate: () => true` dans l'instance `axios`


## Global error handler

C'est le **dernier des middlewares** qui prend 4 param√®tres : 
- `error`
- `req`
- `res`
- `next`

On le branche apr√®s le routeur principal de l'API dans l' `app.ts`.

Si une erreur intervient dans un controleur (qu'importe l'erreur) et qu'elle est lev√©e (`throw`) alors on la r√©cup√®re dans ce middleware.

Permet donc de g√©rer les erreurs de mani√®re globale !