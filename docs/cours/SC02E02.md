# SC02E02 - D√©ploiement

## Menu du jour

- Correction
  - Dockerfile (client)
    - notion : multi-stage build
    - notion : variable d'environnement et argument de build
  - Compose :
    - ajout du client
    - ajout des variables d'environnement

- VM Kourou (VPS)
  - Discuter des diff√©rentes solutions d'h√©bergement existantes
  - Connexion SSH
  - Installation Docker
  - Cloner (GitHub SSH key)

- D√©ploiement
  - Variables d'environnement
  - Lancement des conteneurs
  - Bonus : reverse Proxy Nginx

- Challenge
  - Refaire le d√©ploiement (si non termin√©)
    - choix : mode popcorn
    - choix : livecode
    - choix : kho lanta
  - Diagramme de d√©ploiement UML


## Vocabulaire

- **T√©l√©porteur** = VM locale (habituelle)
  - via `VirtualBox`

- **VPS** = VM Cloud = VM Kourou
  - via `SSH` et `https://kourou.oclock.io/ressources/vm-cloud/`


=> On r√©installe son VPS via l'interface histoire de faire un d√©ploiement depuis une machine neuve !


## Correction Dockerfile `client`

Pour la mise en production du Client, il faut : 
- partir de `node:24`
- build le client
- lancer un serveur statique sur le `dist`

- Jusqu'√† pr√©sent, on sert notre dist avec `npm run preview` => adapt√© au dev mais pas √† la prod
- Utilisons maintenant Nginx : on prend notre dossier `dist` et on le sert avec `nginx`


## R√©sum√© des ports 

**En local avec Docker** (dans l'optique de le faire en production) :

- Serveur Postgres (`BDD`) 
  - `5433` (local) -> `5432` (conteneur)

- Serveur HTTP Node.js (`API`)
  - `3001` (local) -> `3000` (conteneur)

- Serveur HTTP (Nginx) (`Client`)
  - `8000` (local) -> `80` (conteneur)

- Serveur HTTP (Apache) (`Adminer`)
  - `8080` (local) -> `8080` (conteneur)


Rappellons nous : 
- notre setup Docker est uniquement **destin√© √† la production** ! 
  - nos conteneurs, on s'en sert pas en local, si ce n'est pour tester notre future production.
- pour d√©velopper, on utilisera nos outils install√©s en local habituel
  - Postgres : `5432`
  - Node.js API : `3000`
  - Vite dev : `5173`


```bash
# Tout est bon !

CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                         NAMES
6c9bc4ae3e12   oquiz-client   "/docker-entrypoint.‚Ä¶"   2 minutes ago   Up 2 minutes   0.0.0.0:8000->80/tcp, [::]:8000->80/tcp       oquiz-client-1
d152f26977ba   adminer:5      "entrypoint.sh docke‚Ä¶"   2 minutes ago   Up 2 minutes   0.0.0.0:8080->8080/tcp, [::]:8080->8080/tcp   oquiz-adminer-1
9eb26c0fcd57   oquiz-api      "docker-entrypoint.s‚Ä¶"   2 minutes ago   Up 2 minutes   0.0.0.0:3001->3000/tcp, [::]:3001->3000/tcp   oquiz-api-1
ea0421b52b8e   postgres:18    "docker-entrypoint.s‚Ä¶"   2 minutes ago   Up 2 minutes   0.0.0.0:5433->5432/tcp, [::]:5433->5432/tcp   oquiz-database-1

# On peut tout √† fait supprimer conteneurs et images du local √† pr√©sent, car on sait que √ßa devrait fonctionner en production
```

![](../resources/screenshots/docker.png)


## Variable d'environnement pour Docker Compose

On cr√©√© deux fichiers : 
- `.env.docker` : pour la production (non versionn√©)
- `.env.docker.example` : pour le local (pour tester)

Quand on lance les services avec compose : 

```bash
# Local
docker compose -p oquiz -f docker-compose.yml --env-file=.env.docker.example up -d 

# Prod
docker compose -p oquiz -f docker-compose.yml --env-file=.env.docker up -d 
```

Utiliser les variables

```yml
services:
  # remplace le lancement de la commande "docker run"
  database:
    image: postgres:18
    restart: unless-stopped # red√©marre la BDD si elle s'est arr√™t√© (√† moins qu'on l'ai stopp√©e manuellement). Ex : si on redemarre la machine -> redemarre la BDD
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - 5433:5432
    volumes:
      - oquiz-volume:/var/lib/postgresql/18/docker
    networks:
      - oquiz-network
```


## GitFlow

Apr√®s la pause, chacun va pouvoir (si vous le souhaiter) d√©ployer son PROPRE d√©p√¥t EN PRODUCTION (--> VPS)

Je vous invite donc √† faire le `GitFlow` pour mettre √† jour votre branche `master` 

- `git checkout master`
- `git fetch prof`
- `git reset --hard prof/main`
- `git push --force`     (‚úÖ important comme √ßa `master` sera √† jour sur GitHub et donc le code que l'on va cloner en prod sera bon !)


## H√©bergement

Deux grandes approches pour d√©ployer un projet : 
- **On premise** : on ach√®te une machine que l'on g√®re nous m√™me
  - ex : le serveur sous l'escalier
  - ex : le Rasberry PI / vieux PC sous Linux connect√© √† internet pour notre site vitrine
- **Cloud** : on loue une machine chez un h√©bergeur

H√©bergeur Cloud :
- `OVH` (üá´üá∑)
  - Kimsufi
- `O2Switch` (üá´üá∑)
- `AWS` (Amazon Web Service)
- `GCP` (Google Cloud Platform)
- `Azure` (Microsoft Azure)
- `Digital Ocean`
- `Surge` (CDN)
- `Hostinger`

Surcouche d'h√©bergement
- `GitHub Pages`
- `Netlify`
- `Render`
- `Railway`
- `Vercel`
- `Heroku`


**IaaS** = Infrastructure as a Service
- on loue l'infrastructure, la machine connect√© √† internet
- on paie pour l'infrastructure qu'on nous met √† notre disposition
- ex : VPS Kourou (Virtual Private Server) qu'on loue chez AWS aujourd'hui

**PaaS** = Plateform as a Service
- l'h√©bergeur nous fourni une "plateforme", ie. une sorte de surcouche √† l'infrastructure pour faciliter la mise en production et la maintenance
- ex : Vercel, Github Pages, Heroku 
- avantage : la plupart des softs sont d√©j√† install√©s, on va juste "d√©poser" nos fichiers.
- avantage : g√©n√©ralement la plateforme offre du monitoring, de la s√©curit√© compl√©mentaire

**SaaS** = `Software as a Service`
- on loue un service, un logiciel pr√™t √† l'emploi
- on paie pour le service qu'on nous met √† disposition
- ex : Dropbox / Google Drive / BBB / Trello / Figma / Gmail 
- avantage : plug and play pour notre utilisation

**DBaaS** = Database as a Service
- un type de PaaS o√π la plateforme fournie est une base de donn√©es (Postgres)
- ex : MongoAtlas


Offres Cloud :

- **Serveur d√©di√© physique** = **Bare metal** = loue la machine compl√®te
  - avantage : profite de toute la puissance de la machine
  - inconv√©nient : couteux

- **Serveur d√©di√© virtuel** = **Virtual Private Server** = **VPS** = loue une VM sur une machine
  - avantage : moins cher mais tout de m√™me isol√© : on reste propri√©t√© de notre propre espace
  - avatange : g√©n√©ralement on a les acc√®s **root** : on peut installer les softwares que l'on souhaite (Postgres, Node, PHP...)
  - inconv√©nient : moins de puissance (√† nuancer), certains clients refusent parfois d'avoir leurs donn√©es sur le m√™me serveur que d'autres client

- **Serveur mutualis√©** = on loue une VM sur une machine mais avec des logiciels d√©j√† install√©
  - ex : un h√©bergement Wordpress chez OVH (avec PHP et MySQL d√©j√† pr√©install√©)
  - avantage : encore moins cher
  - inconv√©nient : pas souvent les acc√®s **root** : on installe pas ce qu'on veut


Dans notre cas, on va h√©berger Oquiz sur un VPS chez AWS. Pour cela, on loue un serveur en passant par la page d'administration des VM : 
- https://kourou.oclock.io/ressources/vm-cloud/
- On d√©marre sa VM (et/ou on la r√©initialise si ce n'√©tait pas fait)


![](../resources/screenshots/iaas-paas-saas.jpg)

## Se connecter au VPS

**SSH** = **Secure SHell** = protocole de communication, g√©n√©ralement utilis√© pour prendre le controle d'une machine √† distance

```bash
# On rep√®re sur la page de gestion de la VM l'adresse SSH de notre VPS et on l'entre
ssh student@PSEUDO-server.eddi.cloud  # avec l'espace entre ssh et l'adresse
```

### Cas 1 : Bloc C

```bash
# On vous demande de confirmer : 
Are you sure you want to continue connecting (yes/no/[fingerprint])?

# R√©ponse
yes

# V√©rification : le prompt devient : 
student@PSEUDO-server:~$
```

## Cas 2 : Bloc A + B

```bash
ssh student@PSEUDO-server.eddi.cloud

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ED25519 key sent by the remote host is
SHA256:F3D/JDtMzK8r0lSbS52oIGsQR3dTPyZ/W4IUTQrkjV8.
Please contact your system administrator.
Add correct host key in /home/student/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/student/.ssh/known_hosts:6
remove with:
ssh-keygen -f '/home/student/.ssh/known_hosts' -R 'PSEUDO-server.eddi.cloud'
Host key for PSEUDO-server.eddi.cloud has changed and you have requested strict checking.
Host key verification failed.
```

Puisque qu'on a REINSTALL√â la VM, l'ID du serveur a chang√©, donc notre h√¥te (local) pense qu'il est possible que quelqu'un √©coute notre communication avec notre serveur. Rassurons nous, on sait que le probl√®me vient de notre r√©installation. Donc on ignore le warning et : 

```bash
# Pour retirer l'erreur (remplacer bien sur par votre pseudo)
ssh-keygen -f '/home/student/.ssh/known_hosts' -R 'PSEUDO-server.eddi.cloud'

# Puis on retombe sur le cas du bloc C : 
# On se connecte en SSH
ssh student@PSEUDO-server.eddi.cloud

# On vous demande de confirmer : 
Are you sure you want to continue connecting (yes/no/[fingerprint])?

# R√©ponse
yes

# V√©rification : le prompt devient : 
student@PSEUDO-server:~$
```

A partir d'ici, v√©rifier bien votre **prompt** : 

```bash
# T√©l√©porteur (VM locale)
student@teleporter:~$

# VPS (VM Cloud)
student@PSEUDO-server:~$

# Pour passer de l'un √† l'autre : 
exit # quitter le VPS -> on retourne sur le t√©l√©porteur
ssh student@PSEUDO-server.eddi.cloud # pour retourner sur le VPS
```

## Bienvenue sur votre VPS

Quelques commandes Linux pratiques. 

Id√©e : faire le tour du propri√©taire

```bash
# Info syst√®me
uname -a 

# Nom de l'h√¥te
hostname

# Nom de l'utilisateur courant
whoami

# Version d'Ubuntu
lsb_release -a

# Dossier courant
pwd

# Voir les variables d'env
printenv

# Espace libre
df -h

# Gestionnaire des t√¢ches (liste des processus)
htop
# Quitter : touche 'q'

# Liste des processus (√† l'instant T)
ps aux

# V√©rifier les ports utilis√©s 
sudo ss -tuln
# MDP sudo (root) de votre VPS : par dessus les nuages
```

## Mettre √† jour sa machine 

**APT** = **Advaced Package Tool** = un gestionnaire de packets pour Linux

- `APT` (pacman, snap) est √† Linux ce que `NPM` (yarn, pnpm) est √† Node.js

| OS      | Gestionnaire de packet |
| ------- | ---------------------- |
| Windows | Chocolatey             |
| MacOs   | HomeBrew               |
| Linux   | APT, pacman, snap      |



```bash
# Mettre √† jour la liste des paquets Linux (ie, l'annuaire des paquets)
‚úÖ sudo apt update

# Mettre √† jour les packages d√©j√† install√©s sur le syst√®me
‚úÖ sudo apt upgrade
# R√©pondre "y" pour accepter les mises √† jour

# Il est possible que vous tombiez sur un ECRAN ROSE => pour mettre √† jour le noyau et/ou relance les services
# Appuyer sur ENTER (plusieurs fois si besoin)


# Apr√®s une mise √† jour importante des packages, bonne pratique : 
# Red√©marrer le syst√®me
sudo reboot

# Patiente 30 secondes et on se reconnecte 
ssh student@PSEUDO-server.eddi.cloud
```


## Pr√©paration de l'environnement de production

**Sans Docker**, on aurait besoin de : 
- Du d√©p√¥t clon√©
- PostgreSQL
- Node.js 24 (donc NVM)
- Installer NGINX
- Cr√©er la BDD √† la main
- D'installer les d√©pendances √† la main
- Cr√©er le build backend et client
- G√©rer les variables d'environnement par service
- Lancer les commandes pour d√©marrer l'API √† la main + Nginx


**Avec Docker**, on a besoin de : 
- Du d√©p√¥t clon√©
- Docker install√©
- G√©rer les variables d'environnement `.env.docker`

### Installer Docker

Pour l'installer, on suit la [documentation pour Ubuntu](https://docs.docker.com/engine/install/ubuntu/)

```bash
# A-t-on besoin d'installer Docker ? 
docker -v  # ==> ‚ùå pas de version => pas de Docker
```

```bash
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
# (copier toutes les lignes d'un coup)
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

```bash
# Re-mettre √† jour la liste des packages
sudo apt-get update

# Installation
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
# MDP : par dessus les nuages
# Confirmer l'installation avec 'y'


# Confirmation de l'installation 
sudo docker run hello-world
# ==> Hello World!
```


```bash
# Pour √©viter d'avoir √† taper "sudo" pour toutes les commandes Docker, on peut ajouter l'utilisant courant (student / `whoami`) dans le groupe de permissions (Linux) Docker
sudo usermod -aG docker $USER

# Red√©marrer le service docker
sudo systemctl restart docker

# Red√©marrer le syst√®me
sudo reboot # Patienter une minute que votre t√©l√©porteur red√©marre

# On attend une bonne minute puis on se re-connecte √† notre VPS
ssh student@PSEUDO-server.eddi.cloud

# On teste
docker run hello-world # üéâ Fonctionne sans avoir besoin de sudo !
```

## G√©n√©rer une clef SSH

```bash
‚ùå git clone git@github.com:O-clock-Dublin/SC01234-oquiz-PSEUDO.git
# fatal: Could not read from remote repository.
```

Raison : c'est une s√©curit√© de GitHub, on ne peut pas cloner depuis n'importe quelle machine sans avoir les droits.

Pour avoir les droits : 
- il faut cr√©er une paire de clef SSH sur la machine sur laquelle on souhaite cloner
- d√©clarer la cl√© publique aupr√®s de GitHub (dans les settings du d√©p√¥t)

[Documentation](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)

```bash
# G√©n√©rer la paire de clef SSH
# ‚ö†Ô∏è Remplacer par son email GitHub
ssh-keygen -t ed25519 -C "your_email@example.com"
# Choix du nom de fichier : ENTER (par d√©faut)
# Choix passphrase : ENTER (par d√©faut)
# Choix passphrase : ENTER (confirmer)

# V√©rifier la bonne cr√©ation de la paire SSH
ls .ssh
# id_ed25519      -> cl√© priv√© (reste au chaud)
# id_ed25519.pub  -> cl√© publique (la d√©clarer sur GitHub)

# D√©marrer l'agent SSH
eval "$(ssh-agent -s)"

# Ajoutez votre cl√© priv√©e SSH √† ssh-agent
ssh-add ~/.ssh/id_ed25519

# Copier le contenu de la clef SSH publique
cat ~/.ssh/id_ed25519.pub
# Copier toute la ligne (y compris `ssh-ed25519 XXXXXXXXXXXXXX mail@oclock.io`)
```

## D√©clarer la clef SSH aupr√®s de GitHub

2 options possibles : 
- **Option 1** : d√©clarer la clef publique directement au niveau du COMPTE UTILISATEUR
  - avantage : on peut ensuite cloner n'importe quel d√©p√¥t de l'utilisateur
  - inconv√©nient : moins s√©curis√©, car n'importe qui avec acc√®s au VPS pourra alors r√©cup√©rer tous les d√©p√¥ts de l'utilisateurs, mais √©galement avec les droits d'√©criture ! 
- **Option 2** : d√©clarer la clef publique au niveau des SETTINGS DU DEPOT
  - avantage : on ne pourra cloner que le d√©p√¥t (et on peut m√™me choisir en lecture seul)
  - inconv√©nient : il faut une clef diff√©rente par d√©p√¥t (on peut pas r√©utiliser deux fois la m√™me clef SSH)

Sur l'interface de Github
  - Se rendre sur son d√©p√¥t :
    - https://github.com/O-clock-Copenhague/SC01234-oquiz-PSEUDO
  - `Settings` > `Deploy Key` > `Add deploy key`
    - https://github.com/O-clock-Copenhague/SC01234-oquiz-PSEUDO/settings/keys/new
  - Remplir les champs : 
    - `Title` : VPS Kourou AWS (ou ce qu'on veut)
    - `Key` : copier/coller du terminal
      - en entier : `ssh-ed25519 .... email`
    - `Allow write access` : laisser d√©choch√© 
  - Valide

### Cloner le d√©pot

```bash
# S'assurer d'√™tre sur son VPS
hostname # ==> PSEUDO-server.cloud.eddi.xyz # ==> sinon on se reconnecte au VPS avec ssh ...

# Rester √† la racine (dossier utilisateur)
cd /home/student

# Cloner le d√©pot 
git clone git@github.com:O-clock-Dublin/SC01234-oquiz-PSEUDO.git
# => confirmer avec "yes"

# V√©rification
ls # => ‚úÖ le d√©p√¥t est l√†
```

![](../resources/screenshots/ssh.png)

## D√©ploiement (enfin !)

```bash
# Toujours sur le VPS
hostname

# On se d√©place dans le d√©p√¥t
cd SC01234-oquiz-PSEUDO

# On v√©rifie qu'on a tout ce qu'il nous faut
ls -a # => .env.docker.example + docker-compose.yml

# Cr√©er le fichier d'environnement (en copiant l'exemple)
cp .env.docker.example .env.docker

# On √©dite le fichier .env.docker
nano .env.docker
# Pour sauvegarder : `CTRL + S`   ou `CTRL + O` puis ENTER
# Pour quitter : `CTRL + X`
```

```bash
# Database
POSTGRES_USER=oquiz
POSTGRES_PASSWORD=oquizsecure
POSTGRES_DB=oquiz
DATABASE_PORT=5433

# API
ALLOWED_ORIGIN=http://PSEUDO-server.eddi.cloud:8000  # le backend autorise ce front !
API_PORT=3000

# Client
VITE_API_BASE_URL=http://PSEUDO-server.eddi.cloud:3000/api  # le client appelle le backend sur cette URL
CLIENT_PORT=8000

# Adminer
ADMINER_PORT=8080


# Pour sauvegarder : `CTRL + S`   ou `CTRL + O` puis ENTER
# Pour quitter : `CTRL + X`
```

```bash
# Confirmer les variables
cat .env.docker

# D√©ploiement (moment de v√©rit√©)
docker compose -p oquiz -f docker-compose.yml --env-file=.env.docker up -d 

# V√©rification
docker ps 
```

```bash
# On test (depuis Chrome, le m√™me Chrome que l√† o√π vous avez l'interface de gestion des VM ouverte)
API : http://PSEUDO-server.eddi.cloud:3000/api/health
API : http://PSEUDO-server.eddi.cloud:3000/api/users

BDD : http://PSEUDO-server.eddi.cloud:8080
# Systeme : PostgreSQL
# Serveur : database
# Utilisateur : oquiz
# Mot de passe : oquizsecure
# Base de donn√©es : oquiz

CLIENT : http://PSEUDO-server.eddi.cloud:8000
```

Probl√©matique : 
- comment Jeff va se souvenir de tous ces ports ? 
Solution : 
- rajouter **un service REVERSE-PROXY** qui va permettre d'avoir des sous domaine et des redirections vers les services appropri√©s

```
CLIENT : 
http://oquiz.PSEUDO-sever.eddi.cloud --> http://PSEUDO-server.eddi.cloud:8000

API :
http://oquiz-api.PSEUDO-sever.eddi.cloud  --> http://PSEUDO-server.eddi.cloud:3000

ADMINER : 
http://oquiz-admin.PSEUDO-sever.eddi.cloud --> http://PSEUDO-server.eddi.cloud:8080
```

## Reserve Proxy 

Actuellement : 

```bash
CLIENT :  http://PSEUDO-server.eddi:cloud:8000
API :     http://PSEUDO-server.eddi.cloud:3000
ADMINER : http://PSEUDO-server.eddi:cloud:8080
```

Ce qu'on veut :

```bash
CLIENT :  http://oquiz.PSEUDO-server.eddi:cloud(:80)
API :     http://oquiz-api.PSEUDO-server.eddi.cloud(:80)
ADMINER : http://oquiz-admin.PSEUDO-server.eddi:cloud(:80)
```


Note : 
- port par d√©faut pour HTTP  : **port 80**
  - exemple : http://httpforever.com:80
- port par d√©faut pour HTTPS : **port 443**
  - exemple : https://oclock.io:443


2 options pour la configuration du Reverse proxy : 
- soit un service en plus dans le docker compose
  - ==> pour profiter de Docker !
- soit directement installer Nginx sur le serveur de production et g√©rer √† part la configuration 
  - ==> mon conseil pour l'apoth√©ose (si beson !)


## Mettre en place le reverse proxy

- Soit Gitflow / soit rajouter manuellement le fichier `proxy/nginx.conf`
  - attention √† bien mettre votre `PSEUDO` √† la place du `enzoclock`

- Modifier le fichier `docker-compose.yml` pour rajouter le service `proxy`

- Commit / Push `master`

- En production : 
  - pull (master)
  - √©teindre les conteneurs (`down`)
  - modifier les variables d'environnement si besoin (API_BASE_URL et/ou ALLOWED_ORIGIN)
  - relancer les conteneurs (`up`)

![](../resources/screenshots/reverse-proxy.png)
