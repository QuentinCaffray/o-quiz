# SC02E03 - Tests automatis√©s

## Menu du jour

Correction challenge
- Instructions d√©ploiement
- Diagramme de d√©ploiement

Tests automatis√©s
- Motivation
- Nomenclature
- Documentations et bonnes pratiques

Tests unitaires
- D√©monstration (API : `node:test`)
- D√©monstration (Client : `vitest`)

Tests d'int√©gration
- Environnement de test
- Quelques routes et pleins de tests

(Bonus) Tests end-to-end
- Discussions
- Jeu de tests


## Pourquoi tester ? 

- **Raisons de tester**
	- D√©tecter les regressions (√©viter les crash, √©viter les probl√®mes de s√©curit√©)
	- Assurer une bonne qualit√© logicielle (se rassurer)
	- S'int√©grer dans une pipeline int√©gration et de d√©ploiement continue (pr√©-check avant mise en production)
	- Sert de documentation -> d√©duire le fonctionnement du syst√®me en lisant les tests sans m√™me lire le code

## Types de tests existants

- [Testing : JavaScript best practices](https://github.com/goldbergyoni/javascript-testing-best-practices)
- [Testing : Node.js best practices](https://github.com/goldbergyoni/nodejs-testing-best-practices)

- **Tests manuels**
  - `console.log`
  - `requests.http` / `api.http` / RestClient  (tests versionn√©s ! peuvent-√™tre rejou√© facilement)
  - ThunderClient / Postman / Bruno / Insomnia / Chrome (Clients HTTP)
  - **Plan de tests**
    - √† d√©faut de coder des tests automatis√©s (manque de temps), il est toujours bon de pr√©voir un plan de test pr√©cis de certaines fonctionnalit√©s de l'application.
    - on parle souvent d'un **jeu d'essai de test**

- **Tests unitaires** = on test une fonction isol√©e
  - ex : `function isComplexPassword(password: string): boolean`
  - ex : `function computeScore(choices: number[], goodChoices: number[]): number`
  - permet g√©n√©ralement de tester la "logique m√©tier" (business logic) d'une fonction

- **Tests d'int√©gration** = on test une sous partie d'un syst√®me
  - on parle aussi de **component testing** ou **specification testing**
  - ex : `GET /api/users` et v√©rifier qu'elle renvoie les users de la BDD
  - ex : `POST /api/auth/register` et v√©rifier que l'utilisateur est bien cr√©√© en BDD

- **Tests E2E** = End-to-End = on test l'int√©gralit√© du syst√®me
  - on parle de test bout-en-bout
  - ex : tester l'affichage de la home page (plus-value interessante)
  - ex : tester que le bouton de validation d'un formulaire se d√©sactive si le mot de passe n'est pas sufissament complexe (peu de valeur)
  - le **jeu d'essai de test** est une sorte de set de tests E2E manuel


Vocabulaire (abus de language):
- **Contract Tests** = v√©rifier que le code respecte le contrat (notamment entre des micro-services)
- **Snapshot Testing** = v√©rifier que le rendu actuel est le m√™me que pr√©c√©demment
- **Non-regression Tests** = √©viter les r√©gressions
- **UI Testing** = tester des composant UI, √† l'aide d'un [storybook](https://storybook.js.org/) par exemple

## Jeu d'essai de test

G√©n√©ralement, on trouve ici les cas fonctionnels les plus critique pour l'application. A coupler avec par exemple des tests bout-en-bout automatis√©s (mais pas n√©cessairement)

| Cas √† tester                    | Donn√©es d‚Äôentr√©e                                      | Attendu                                                  |
| ------------------------------- | ----------------------------------------------------- | -------------------------------------------------------- |
| Login avec credentials valides  | email: `user@test.com` <br> password: `password123`   | ‚úÖ Redirection tableau de bord                           |
| Login avec mauvais mot de passe | email: `user@test.com` <br> password: `wrongpass`     | ‚ùå Message "mot de passe invalide"                       |
| Inscription nouvelle adresse    | email: `newuser@test.com` <br> password: `newpass123` | ‚úÖ Cr√©ation compte + redirection                         |
| Token expir√©                    | token expir√© en DB                                    | ‚ùå Redirection vers login avec message "Session expir√©e" |


## TDD

**Test Driven Development** = "coder" le test avant la fonctionnalit√© 
- pr√©voir pr√©cisement le fonctionnement de la fonctionnalit√© avant de la coder
- user stories sont une forme de TDD

Dans l'industrie, c'est courant de coder le test avant la fonctionnalit√©, dans une certaine limite, selon les fonctionnalit√©s

## Logique "m√©tier"

[En savoir plus](https://chatgpt.com/share/6916eeae-bbe8-8005-8d3a-ae13b06908a0)

-------------------------

## Tests unitaires

Pour √©crire des tests, il nous faut deux choses : 
- **test runner**
  - l'ex√©cutable qui lance les tests
  - ex : 
    - `node:test`
    - `jest`
    - `vitest`
    - `mocha`

- **biblioth√®que d'assertion**
  - librairie qui nous aide √† r√©diger le code qui "v√©rifie" que la fonction fait bien ce qu'on attend d'elle
  - ex : 
    - `node:assert`
    - `jest`
    - `vitest`
    - `chai`


| Besoin                                   | Recommandation              |
| ---------------------------------------- | --------------------------- |
| **Projet minimaliste Node.js**           | `node:test` + `node:assert` |
| **Projet moderne (React, Vue, TS)**      | `vitest` (tout-en-un)       |
| **Projet backend classique et flexible** | `mocha` + `chai`            |
| **Projet frontend principalement**       | `jest` (tout-en-un)         |


### C√¥t√© backend

- Test runner : `node:test`
- Biblioth√®que d'assertion : `node:assert`

Avantage : natif, r√©cent, rien √† installer !
Inconv√©nient : moins complet que d'autres approches

### C√¥t√© frontend

- Test runner : `vitest`
- Biblioth√®que d'assertion : `vitest`

Avantage : complet, moderne, rapide
Inconv√©nient : √† installer

```bash
npm install --save-dev vitest --prefix client
```

```json
"test": "vitest run", // lancer les tests une fois
"test:watch": "vitest" // lancer en mode watch
```


### Structure d'un test

- Bloc "describe" = regroupement de tests
- Fonction "it" = un test

3 parties (`AAA`): 
- `Arrange` : pr√©paration des donn√©es
- `Act` : √©x√©cution du code
- `Assert` : v√©rification

Lancer les tests avec `node:test` : 
- `node --test chemin_du_fichier`
- ==> SCRIPT NPM

## Regex

- [Regex101 pour apprendre √† √©crire des Regex](https://regex101.com/)


## Test d'int√©gration

Tester une sous partie du syst√®me : par exemple le bon fonctionnement de l'API

Ex : 
- tester que la route `/api/users` nous renvoie bien tous les utilisateurs de la BDD
- tester que la route `/api/health` nous renvoie bien un JSON correct
- tester que la route `/api/users/ID` nous renvoie l'utilisateur s'il existe
- tester que la route `/api/users/ID` nous renvoie une 404 si l'utilisateur demand√© n'existe pas

Plus value : 
- une fois ces tests impl√©menter, on aura pas besoin de d√©gainer `api.http` pour tester manuellement les endpoints pour nous assurer qu'il n'y a pas regression !


```js
// PROBLEME 1 : 
// pour pouvoir faire l'appel fetch, il faut que le serveur tourne
// avant de faire "npm run test:spec", il faut donc manuellement lancer un serveur `npm run dev`
// -> deux commandes √† faire -> p√©nible
// SOLUTION : 
// - avant de lancer les tests, on fait en sorte que le SETUP des tests lance un serveur HTTP de TEST (par ex : 7357)
// - une fois tous les tests termin√©, on √©teint ce serveur

// PROBLEME 2 : 
// si on ajoute nos utilisateurs dans notre BDD de d√©veloppement, les tests vont d√©pendre de notre seeding
// on ne pourra pas lancer les tests deux fois, sans faire planter les tests (car on cumule l'√©tat pr√©c√©dent avec le nouvel √©tat)
// SOLUTION : 
// - plut√¥t que d'√©crire dans la BDD DE DEV (oquiz/oquiz/oquiz), on va √©crire dans une BDD DE TEST (oquiztest/oquiztest/oquiztest)
// - on videra le contenu de cette BDD entre chaque test, histoire que chaque test soit ind√©pendant des autres

// OBJECTIF : 
// - AVANT les tests
//   - lancer un serveur HTTP 7357  --> app.listen()
//   - cr√©er une BDD oquiztest      --> on lancera un conteneur Postgres !
//   - avec nos tables              --> lancer migrations

// - ENTRE chaque test
//   - vider les donn√©es de la BDD oquiztest    --> commande SQL 


// - APRES les tests
//   - √©teindre le serveur            --> server.close()
//   - supprimer la BDD oquiztest     --> √©teindre le conteneur Postgres !
```

## üëè Time to dev' 

On veut coder les routes des `/levels`

Pour commencer :
- `GET /levels`

### D√©marche de d√©veloppement 

Base de donn√©es : 
- 1) Ajouter un nouveau mod√®le dans le `schema.prisma` : `Level`
- 2) G√©n√©rer les fichiers de migrations : `npm run db:migrate:dev`
  - g√©n√®re le fichier + applique + reconstruit le client `prisma`
- 3) Modifier le `seeding.ts` pour √©chantillonner quelques `levels`
- 4) Reset BDD : `npm run db:reset` 
  - re-appliquer les migrations + appliquer le seeding

Router : 
- 1) Cr√©er `levels.router.ts` o√π on d√©clare la route
- 2) Brancher le routeur sur le routeur principal de l'API `index.router.ts`

Controleur : 
- 1) Cr√©er le fichier `levels.controller.ts`
- 2) Rajouter la m√©thode appropri√©e : `getAllLevels`
- 3) Renvoyer un objet vide pour tester 
- 4) Tester manuellement cette route : `Chrome` et/ou `api.http`
- 5) Impl√©menter la fonction

Tests : 
- 1) V√©rifier que s'il y a plusieurs levels dans la BDD, ils sont tous renvoy√©s
- 2) V√©rifier que tous les champs des levels sont renvoy√©s (id, name, created_at, updated_at)


## Mise en place de l'environnement de test 

- N'oubliez pas qu'il y a plusieurs `package.json` : 
  - `npm install --prefix api`
  - `npm install --prefix client`

- Lancer un script ? 
  - OPTION 1 : `cd api` et `npm run ....`
  - OPTION 2 : `npm run ..... --prefix api`


Rappel : 
- c'est les tests EUX-M√äMES qui lancent le conteneur `oquiztest` : ce n'est pas √† nous de le faire manuellement
