# SC01E04 - TypeScript & Architecture

## Menu du jour

- Lecture Correction (30min)
  - Modélisation YouTube

- Introduction à TypeScript (2h)
  - Intérêt & exécution
  - Typage (demo)

- Architecture TypeScript (2h)
  - Mise en place de l'API
  - Mise en place de l'ORM

- Challenge
  - exercices
  - challenge avec une API
  - lancer oquiz en local
  - QCM ECF
  - QS Formateur


## NVM = Gestionnaire de version pour Node ==> 

- NPM = Node Package Manager
- NVM = Node Version Manager

Ouvrir un terminal (si possible dans VSCode) :
- `nvm --version`  => ✅

Installer la version 24 de node : 
- `node -v` ==> 22
- `nvm install 24`
- `nvm use 24`
- `nvm alias default 24`
- `node -v` ==> 24


## Bilan

**TypeScript** = 
- un typage statique fort en surcouche à JavaScript
- transpile le code vers JS avant de l'exécuter 
  - soit explicitement à l'aide de `TSC`
  - soit implicitement via du Node.js morderne
- l'ajout d'un typage EXPLICITE dans JavaScript

## Typescript

### Types scalaires

- `number`
  - ex : `42`, `3.14`, `Math.random()`
  - ❌ float / integer / double 

- `string`
  - ex : `"hello"`, `'text'`

- `boolean`
  - ex : `true`, `false`

### Types nullables

- `null` : absence explicite de valeur
- 
- `undefined` : absence implicite de valeur 
  - (par exemple, on ne fourni pas à une fonction un attribut facultatif, alors il vaut `undefined`)

- `void` : pour les fonctions qui ne renvoie rien, équivalent de `undefined`

### Types utilitaires

- `any` : type fourre-tout => revient à faire du JS
  - peut servir pour **contourner une problématique** de typage trop délicate (ou peut interessante)
  - en général, si on peut typer explicitement on le fait

- `unknown` :
  - pour indiquer qu'on ne maitrise pas ce qu'on a dans la variable
  - donc forcer le dev à faire des vérifications avant de la manipuler

- `never` : 
  - pour dire qu'il y a RIEN dans la variable


### Types dérivés des classes

- `Date`
- `Regex`
- ...
- et toutes les autres classes JS et celles qu'on créé nous même

### Typer les fonctions

```ts
function maFonction(param1: TYPE, param2: TYPE): TYPE_RETOUR {
  // Implémentation
}

// Le Type de retour peut être inféré directement par typescript qui analyse le corps de la fonction
```

### Typer les tableaux

```ts
TYPE[]
string[]

Array<TYPE>
Array<Date>
```


### Types Unions

```ts
type Condiment = "chilly" | "salt" | "pepper";
``` 

### Typer les objets

```ts
interface User {
  firstname: string;
  lastname: string;
  age?: number;       // Propriété optionnelle
  hobbies?: string[]; // Propriété optionnelle
}

interface Wizard extends User {
  house: House;
  knownSpells: Spell[];
  greetings: () => void;
  dealDamage: () => number;
}
```

## Rappels `const`

`const` = interdit la ré-affectation de la variable

```ts
const nbs = [4, 7, 9];
nbs.push(10);          // ==> ✅ car pas de ré-affectation, on modifie le contenu de la variable "sans changer sa case mémoire"
nbs = [4, 7, 9, 10];   // ==> ❌ ré-affectation : on change la case mémoire
```

## Architecture API 

[Spécifications](../conception/api-rest/endpoints.md)

### Mise en place

- Créer un dossier `api`
  - `mkdir api`

- Initialiser NPM
  - `npm init -y`

- Installer des dépendances
  - ✅ express ===> ✅@types/express
  - dotenv => ❌ `node --env-file=.env`
  - typescript => pour avoir le compilateur => pour la prod
  - pg => ❌ prisma à la place
  - nodemon => ❌ `node --watch`

- Ajout d'un `.gitignore`

- Serveur Express HTTP
  - tester le mode dev (`node --watch index.ts`)

- Prévoir la production 
  - installer le TypeScript compiler
    - `npm install --save-dev typescript`
  - initialiser la configuration TypeScript
    - `npx tsc --init`  ===> `tsconfig.json` 
  - ajout de 2 scripts : 
    - npm run build (==> créer le `dist` à l'aide de tsc)
    - npm run start (==> lancer le fichier .js généré)

- Gérer les variables d'env
  - `touch .env .env.example`
  - `touch config.ts` pour wrapper les variables
  - `--env-file=.env` dans les scripts

### Rappels NPM 

- `npm init`
  - créer le `package.json`

- `npm install XXXXX`
  - déclarer un package dans le `package.json`
  - et le télécharger dans les `node_modules`

- `npm install`
  - réinstaller toutes les dépendances déclarées dans le `package.json`
    - après un clone par exemlpe
    - ou après un gitflow

- `npm install --save-dev XXXX`
  - installer un package comme dépendance de dev (pour les outils qui ne servent qu'en développement)
  - par exemple, pour les linter, les compilateurs

- `npx package` 
  - exécuter un binaire d'un package rangé dans les `node_modules`
  - (en général, on en pas besoin, car on passe par le `package.json` et les script)

### Package NPM et Typescript

- `DT` = `Definitely Typed`
  - le package est codé en JS, et il faut installer les types à part !
- `TS` = TypeScript
  - le package est codé en TS, pas necessaire d'installer les types

### Variables d'environnement 

Il faut :
- les déclarer : 
  - ==> `.env`
- les charger
  - ==> `import "dotenv/config"` (installer dotenv)
  - OU (plus moderne)
  - ==> `--env-file=.env` (Node >= 18)
- les utiliser
  - ==> `process.env.XXXX`
  - ==> wrapper dans un fichier `config.ts` (pratique !)

### Archictecture proposée

- Un `quiz` (one)
- Des `quizzes` (many)

```
/api
  index.ts
  config.ts
  /src
    /routers
      index.router.ts
      users.router.ts
      levels.router.ts
    /controllers
      main.controller.ts
      users.controller.ts
      levels.controller.ts
    /middlewares
      not-found.middleware.ts
    /models
      index.models.ts
```

## Prisma

Documentations : 
- [Quick start](https://www.prisma.io/docs/getting-started/quickstart-prismaPostgres) 
- [Start from scratch](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-prismaPostgres)


**ORM** = **Object-Relationnal Mapping** 
- idée : faire le lien entre des objets (code) et des tables ("relations") dans la BDD

ORM =
- Sequelize
- TypeORM
- Drizzle
- Lucid
- Eloquent (PHP)
- Doctrine (PHP)

Pourquoi Prisma : 
- beaucoup plus facile à configurer avec TypeScript

Prisma = ORM qui inclut : 
- un **système de migration**
  - générer les tables en "une commande"
  - modifier les tables alors que la BDD existe et que elle comporte déjà des données
- un **GUI pour observer la BDD**
  - équivalent de `pgAdmin`, `DBeaver` etc...
- un **client de connexion à la BDD**
  - équivalent de `pg` ou de `Model.findMany()`
  - extrèment bien typé en TS => auto-complétion complète !


### Installation

- `npm install --save-dev prisma @types/node`
- `npm install @prisma/client`

Générer un schéma pour décrire le format de ma base de données :
- équivalent en Sequelize des `modèles`
- `npx prisma init`

### Explication des commandes Prisma (`package.json`)


```json
// A partir du 'schema.prisma', génère un/des fichier(s) de migrations (SQL) et les applique sur la BDD
"db:migrate:dev": "prisma migrate dev",

// Applique les migrations non encore appliquées sur la BDD (pratique pour la production)
"db:migrate:deploy": "prisma migrate deploy",

// Supprime les tables de la base de données puis les récrée en appliquant toutes les migrations (tables vides)
"db:migrate:reset": "prisma migrate reset --force",

// A partir du 'schema.prisma', génère le client Prisma (prisma/generated)
"db:generate": "prisma generate",

// Exécute le script de seeding pour insérer des données d'échantillonnage dans la base de données
"db:seed": "node --env-file=.env ./src/models/seeding.ts",

// Réinitialise la base de données (migrations + seed)
"db:reset": "npm run db:migrate:reset && npm run db:seed",

// Ouvre Prisma Studio (interface graphique pour visualiser/modifier la BDD)
"db:studio": "prisma studio",
```
